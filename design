* schema
** manifest db
*** tables
**** manifests
     version          INTEGER PRIMARY KEY,
     name             TEXT NOT NULL,
     content_url      TEXT NOT NULL,
     version_url      TEXT NOT NULL,
     format           INTEGER NOT NULL
**** paths
     id               INTEGER PRIMARY KEY,
     path             TEXT NOT NULL,
     path_type        INTEGER NOT NULL,
     parent           INTEGER REFERENCES path_objects(id),
     update_version   INTEGER NOT NULL,
     disk_size        INTEGER,
     download_size    INTEGER,
     hash             TEXT,
     status           INTEGER NOT NULL
**** packages
     id               INTEGER PRIMARY KEY,
     name             TEXT NOT NULL,
     update_version   INTEGER NOT NULL,
     package_version  TEXT NOT NULL,
     disk_size        INTEGER,
     download_size    INTEGER,
     status           INTEGER NOT NULL
**** bundles
     id               INTEGER PRIMARY KEY,
     name             TEXT NOT NULL,
     update_version   INTEGER NOT NULL,
     disk_size        INTEGER,
     download_size    INTEGER,
     status           INTEGER NOT NULL
**** deltas
     id               INTEGER PRIMARY KEY,
     path_id          REFERENCES path_objects(id),
     from_version     INTEGER NOT NULL,
     to_version       INTEGER NOT NULL,
     download_size    INTEGER,
     hash             TEXT
**** renames
     id               INTEGER PRIMARY KEY,
     from_path        REFERENCES path_objects(id),
     to_path          REFERENCES path_objects(id),
     from_version     INTEGER NOT NULL,
     to_version       INTEGER NOT NULL
**** path <-> package join table
     path_id          INTEGER NOT NULL,
     package_id       INTEGER NOT NULL,
     PRIMARY KEY(path_id, package_id)
**** path <-> bundle join table
     path_id          INTEGER NOT NULL,
     bundle_id        INTEGER NOT NULL,
     PRIMARY KEY(path_id, bundle_id)
**** package <-> package join table
     package_requires_id INTEGER NOT NULL,
     package_required_id  INTEGER NOT NULL,
     PRIMARY KEY(package_requires_id, package_required_id)
**** package <-> bundle join table
     package_id       INTEGER NOT NULL,
     bundle_id        INTEGER NOT NULL,
     PRIMARY KEY(package_id, bundle_id)
**** bundle <-> bundle join table
     bundle_includes_id INTEGER NOT NULL,
     bundle_included_id INTEGER NOT NULL,
     PRIMARY KEY(bundle_includes_id, bundle_included_id)
*** details
    sqlite
    generated by backend
    needs swupd-client cmdline frontend hooks
    ro generated per release
** installed db
*** tables
**** installed
     type (path | package | bundle)
     type_id (/foo/bar | thing | thinger)
     manually_installed (true | false)
*** details
    sqlite
    generated by frontend
    can be regenerated from existing filesystem if needed
    needs swupd-client cmdline frontend hooks
    db in /var tracking manual installed files/packages/bundles

* ideas
  - directories not owned by package
  - files/symlinks unique per package (per mix?)
  - single full chroot of all packages (per mix?)
  - can still do packs based on bundles like current swupd
  - allows user to install single files with full path (which pull in the file's package)
  - allows user to install single package
  - allows user to install full bundle
  - metadata of bundle content information integrated fully into swupd backend
  - can do packs based on common dependency chains/large packages
  - can allow clients to optimize for download size vs # of requests (maybe even auto tune for speed)
    - download manifest db to compare # of things needed vs size of content
    - can look at download size and delta availability
  - delta and renames tables can contain all occurances for a given format #
  - dependency information comes from rpm file (fed in through chroot builder to the swupd backend)
    - need autospec to learn requires_add/requires_ban
    - need secondary source for run time requirements that can be merged with chroot builder meta data (mixer needs)
    - could come from same source as bundle definition meta data
  - mix addition only capable (two dbs per mix) : need more thought how multiple (3+) mixes interact
    - can reference other mixes and use them as dependencies?
    - duplication allowed (all hashes must match between dbs?)
    - no cycles allowed?
